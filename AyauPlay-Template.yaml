AWSTemplateFormatVersion: '2010-09-09'

Parameters:
  Environment:
    Type: String
    Description: The environment in which this stack is deployed (e.g., dev, prod)
    AllowedValues:
      - dev
      - prod
    Default: dev
  CloudFrontKeyPairId:
    Type: String
    Description: The ID of the CloudFront key pair used for signed URLs
    Default: K2P8QBF4IA7GIQ
  RedshiftMasterUsername:
    Type: String
    Description: Master username for Redshift cluster
    Default: admin
    MinLength: 1
    MaxLength: 128
    AllowedPattern: '([a-z])([a-z]|[0-9])*'
  RedshiftMasterPassword:
    Type: String
    Description: Master password for Redshift cluster (must contain at least 8 characters, including uppercase, lowercase, numbers, and special characters)
    NoEcho: true
    MinLength: 8
    MaxLength: 64
    Default: 'Ay47P1a74py2024!-*#'
    AllowedPattern: ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[@#$%^&+=!]).*$
    ConstraintDescription: Must be at least 8 characters containing at least one uppercase letter, one lowercase letter, one number, and one special character (@#$%^&+=!)
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID where Redshift cluster will be deployed
    Default: vpc-0b4228448dcd82f4d
  RedshiftSubnets:
    Type: List<AWS::EC2::Subnet::Id>
    Description: List of subnet IDs for Redshift cluster
    Default: >-
      subnet-0098ced055bf20380,subnet-06cbeea76c0113820,subnet-0243375a1f089435e,subnet-055f6bbceddc8c7ec,subnet-04ddb80a25000f797,subnet-0c24f5e04569b6916
  VpcCidr:
    Type: String
    Description: CIDR block for VPC (e.g., 10.0.0.0/16)
    Default: 172.31.0.0/16
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$

Resources:
  # Cognito User Pool for user authentication
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub UserPool-${Environment}  # Name of the user pool
      AliasAttributes:
        - preferred_username
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8  # Minimum password length
          RequireUppercase: true  # Require at least one uppercase letter
          RequireLowercase: true  # Require at least one lowercase letter
          RequireNumbers: true  # Require at least one number
          RequireSymbols: true  # Require at least one symbol
      AutoVerifiedAttributes:
        - email  # Automatically verify email addresses
      Schema:
        - Name: email
          Required: true  # Email is required
          Mutable: true  # Email can be updated
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: true  # Only admins can create users

  # Admin group with elevated permissions
  AdminGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      GroupName: admin  # Name of the group
      UserPoolId: !Ref UserPool  # Reference to the user pool
      Description: Admin group with elevated permissions

  # Client group with standard permissions
  ClientGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      GroupName: client  # Name of the group
      UserPoolId: !Ref UserPool  # Reference to the user pool
      Description: Client group with standard permissions

  # S3 bucket to store uploaded songs
  SongsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub songs-bucket-${Environment}  # Name of the S3 bucket
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: [GET, PUT, POST, DELETE]
            AllowedOrigins:
              - !If
                - IsDev
                - 'http://localhost:5173'
                - '*'
            MaxAge: 3000

  # CloudFront Origin Access Control
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub OAC-songs-${Environment}
        Description: Origin Access Control for Songs Bucket
        SigningProtocol: sigv4
        SigningBehavior: always
        OriginAccessControlOriginType: s3

  # CloudFront distribution for song streaming
  SongsDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: ''
        Origins:
          - DomainName: !GetAtt SongsBucket.RegionalDomainName
            Id: S3Origin
            S3OriginConfig:
              OriginAccessIdentity: ''
            OriginAccessControlId: !GetAtt CloudFrontOriginAccessControl.Id
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: https-only
          TrustedSigners:
            - self
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
            - OPTIONS
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none

  # Update S3 bucket policy to allow CloudFront access
  SongsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref SongsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub ${SongsBucket.Arn}/*
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${SongsDistribution.Id}

  # Lambda function to handle song uploads
  UploadSongsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub UploadSongsLambda-${Environment}  # Name of the Lambda function
      Handler: index.handler  # Handler method
      Role: !GetAtt LambdaExecutionRole.Arn  # IAM role for the Lambda function
      Code:
        ZipFile: |
          import json
          import boto3
          import base64
          import os
          import uuid

          # Initialize S3 and Redshift clients
          s3 = boto3.client('s3')
          redshift_data = boto3.client('redshift-data')

          # Define allowed audio file extensions and their MIME types
          ALLOWED_EXTENSIONS = {'.wav', '.mp3', '.aac'}
          CONTENT_TYPES = {
              '.wav': 'audio/wav',
              '.mp3': 'audio/mpeg',
              '.aac': 'audio/aac'
          }

          def is_valid_audio(filename):
              """
              Check if the file has an allowed audio extension
              Args:
                  filename (str): Name of the file to check
              Returns:
                  bool: True if extension is allowed, False otherwise
              """
              ext = os.path.splitext(filename)[1].lower()
              return ext in ALLOWED_EXTENSIONS

          def get_content_type(filename):
              """
              Get the MIME type for a file based on its extension
              Args:
                  filename (str): Name of the file
              Returns:
                  str: MIME type of the file or default octet-stream
              """
              ext = os.path.splitext(filename)[1].lower()
              return CONTENT_TYPES.get(ext, 'application/octet-stream')

          def handler(event, context):
              """
              Main Lambda handler for file uploads
              Args:
                  event (dict): API Gateway event
                  context (object): Lambda context
              Returns:
                  dict: API Gateway response
              """
              try:
                  # Parse the request body and decode the file
                  body = json.loads(event['body'])
                  file_content = base64.b64decode(body['file'])
                  file_name = body['fileName']
                  title = body['title']
                  author = body['author']
                  performer = body['performer']
                  ISRC = body['ISRC']
                  IPI = body['IPI']
                  code = body['code']
                  duration = body.get('duration', 0)
                  art_location = body.get('art_location', '')

                  # Validate file type
                  if not is_valid_audio(file_name):
                      return {
                          'statusCode': 400,
                          'body': json.dumps('Only .wav, .mp3, and .aac files are allowed')
                      }

                  # Get the environment-specific bucket name
                  bucket_name = f"songs-bucket-{os.environ['ENVIRONMENT']}"
                  
                  # Generate a unique key for the S3 object
                  s3_key = f"{uuid.uuid4()}_{file_name}"
                  
                  # Upload file to S3 with proper content type
                  s3.put_object(
                      Bucket=bucket_name,
                      Key=s3_key,
                      Body=file_content,
                      ContentType=get_content_type(file_name)
                  )

                  # Extract user information from Cognito claims
                  claims = event['requestContext']['authorizer']['claims']
                  uploaded_by = claims['sub']

                  # Insert song details into the database
                  sql = f"""
                  INSERT INTO songs (song_id, title, author, performer, ISRC, IPI, code, duration, s3_key, art_location, uploaded_by, uploaded_at)
                  VALUES ('{uuid.uuid4()}', '{title}', '{author}', '{performer}', '{ISRC}', {IPI}, {code}, {duration}, '{s3_key}', '{art_location}', '{uploaded_by}', GETDATE());
                  """
                  redshift_data.execute_statement(
                      ClusterIdentifier=os.environ['REDSHIFT_CLUSTER_ID'],
                      Database=os.environ['REDSHIFT_DATABASE'],
                      DbUser=os.environ['REDSHIFT_DB_USER'],
                      Sql=sql
                  )

                  return {
                      'statusCode': 200,
                      'body': json.dumps('File uploaded and song details stored successfully')
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }
      Runtime: python3.8  # Runtime environment
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          REDSHIFT_CLUSTER_ID: !Sub ayauplay-cluster-${Environment}
          REDSHIFT_DATABASE: ayauplaydb
          REDSHIFT_DB_USER: !Ref RedshiftMasterUsername

  # Lambda for playlist management
  PlaylistManagementLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub PlaylistManagementLambda-${Environment}
      Handler: index.handler
      Role: !GetAtt PlaylistLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os

          # Initialize AWS clients
          s3 = boto3.client('s3')
          lambda_client = boto3.client('lambda')
          redshift_data = boto3.client('redshift-data')
          bucket_name = f"songs-bucket-{os.environ['ENVIRONMENT']}"
          
          def get_signed_url(object_key):
              """
              Get a signed URL for a song file using SignedUrlLambda
              Args:
                  object_key (str): S3 object key of the song
              Returns:
                  str: Signed URL for CloudFront access
              """
              response = lambda_client.invoke(
                  FunctionName=os.environ['SIGNED_URL_LAMBDA'],
                  InvocationType='RequestResponse',
                  Payload=json.dumps({'object_key': object_key})
              )
              return json.loads(response['Payload'].read())

          def list_playlists(user_id, groups):
              """
              List available playlists based on user permissions
              Args:
                  user_id (str): Cognito user ID
                  groups (list): List of Cognito groups the user belongs to
              Returns:
                  dict: List of available playlists
              """
              is_admin = 'admin' in groups
              if is_admin:
                  prefix = "playlists/"
              else:
                  # Query Redshift for playlists the user has access to
                  sql = f"""
                  SELECT playlist_id FROM playlist_permissions WHERE user_id = '{user_id}'
                  """
                  response = redshift_data.execute_statement(
                      ClusterIdentifier=os.environ['REDSHIFT_CLUSTER_ID'],
                      Database=os.environ['REDSHIFT_DATABASE'],
                      DbUser=os.environ['REDSHIFT_DB_USER'],
                      Sql=sql
                  )
                  playlist_ids = [row['playlist_id'] for row in response['Records']]
                  prefix = f"playlists/{user_id}/" if not playlist_ids else f"playlists/({','.join(playlist_ids)})/"

              response = s3.list_objects_v2(Bucket=bucket_name, Delimiter='/', Prefix=prefix)
              playlists = []
              
              for prefix in response.get('CommonPrefixes', []):
                  playlist_path = prefix.get('Prefix', '').rstrip('/')
                  playlist_name = playlist_path.split('/')[-1]
                  playlists.append(playlist_name)
              
              return {"playlists": playlists}

          def get_playlist_songs(user_id, playlist_name, groups):
              """
              Get all songs in a playlist with signed URLs
              Args:
                  user_id (str): Cognito user ID
                  playlist_name (str): Name of the playlist
                  groups (list): List of Cognito groups the user belongs to
              Returns:
                  dict: List of songs with signed URLs
              """
              is_admin = 'admin' in groups
              # Determine the prefix based on user permissions
              prefix = f"playlists/{playlist_name}/" if is_admin else f"playlists/{user_id}/{playlist_name}/"
              
              # List all songs in the playlist
              response = s3.list_objects_v2(Bucket=bucket_name, Prefix=prefix)
              songs = []
              
              for obj in response.get('Contents', []):
                  song_key = obj['Key']
                  if song_key.endswith(('.wav', '.mp3', '.aac')):
                      signed_url = get_signed_url(song_key)
                      songs.append({
                          'name': song_key.split('/')[-1],
                          'url': signed_url
                      })
              
              return {"songs": songs}

          def handler(event, context):
              """
              Main Lambda handler for playlist operations
              Args:
                  event (dict): API Gateway event
                  context (object): Lambda context
              Returns:
                  dict: API Gateway response
              """
              try:
                  # Extract user information from Cognito claims
                  claims = event['requestContext']['authorizer']['claims']
                  user_id = claims['sub']
                  groups = claims.get('cognito:groups', [])

                  operation = event['httpMethod']
                  query_params = event.get('queryStringParameters', {}) or {}
                  
                  # Handle GET requests for playlist operations
                  if operation == 'GET':
                      if 'playlist' in query_params:
                          return {
                              'statusCode': 200,
                              'body': json.dumps(get_playlist_songs(user_id, query_params['playlist'], groups))
                          }
                      else:
                          return {
                              'statusCode': 200,
                              'body': json.dumps(list_playlists(user_id, groups))
                          }
                  else:
                      return {
                          'statusCode': 405,
                          'body': json.dumps('Method not allowed')
                      }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          SIGNED_URL_LAMBDA: !Ref SignedUrlLambda
          REDSHIFT_CLUSTER_ID: !Sub ayauplay-cluster-${Environment}
          REDSHIFT_DATABASE: ayauplaydb
          REDSHIFT_DB_USER: !Ref RedshiftMasterUsername

  # Lambda for generating signed URLs
  SignedUrlLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub SignedUrlLambda-${Environment}
      Handler: index.handler
      Role: !GetAtt SignedUrlLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from botocore.signers import CloudFrontSigner
          from cryptography.hazmat.primitives import serialization
          from cryptography.hazmat.backends import default_backend
          from datetime import datetime, timedelta
          import rsa

          def handler(event, context):
              """
              Generate signed URLs for CloudFront content
              Args:
                  event (dict): Lambda event containing object key
                  context (object): Lambda context
              Returns:
                  str: Signed URL for CloudFront access
              """
              # Get the S3 object key and construct CloudFront URL
              object_key = event['object_key']
              distribution_domain = os.environ['CLOUDFRONT_DOMAIN']
              url = f"https://{distribution_domain}/{object_key}"
              
              # Retrieve private key from SSM Parameter Store
              ssm = boto3.client('ssm')
              key_param = ssm.get_parameter(Name=os.environ['PRIVATE_KEY_PARAM'], WithDecryption=True)
              private_key = serialization.load_pem_private_key(
                  key_param['Parameter']['Value'].encode('utf-8'),
                  password=None,
                  backend=default_backend()
              )
              
              # Configure CloudFront signer with key pair ID
              key_id = os.environ['KEY_PAIR_ID']
              expire_date = datetime.utcnow() + timedelta(minutes=5)
              
              # Generate and return signed URL
              signer = CloudFrontSigner(key_id, private_key.sign_msg)
              signed_url = signer.generate_presigned_url(
                  url,
                  date_less_than=expire_date
              )
              
              return signed_url
      Runtime: python3.8
      Environment:
        Variables:
          CLOUDFRONT_DOMAIN: !GetAtt SongsDistribution.DomainName
          PRIVATE_KEY_PARAM: !Sub /cloudfront/${Environment}/private-key
          KEY_PAIR_ID: !Ref CloudFrontKeyPairId

  # Lambda function to retrieve all songs in a given playlist
  RetrieveSongsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub RetrieveSongsLambda-${Environment}
      Handler: index.handler
      Role: !GetAtt RetrieveSongsLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          from botocore.signers import CloudFrontSigner
          from cryptography.hazmat.primitives import serialization
          from cryptography.hazmat.backends import default_backend
          from datetime import datetime, timedelta

          s3 = boto3.client('s3')
          lambda_client = boto3.client('lambda')
          bucket_name = f"songs-bucket-{os.environ['ENVIRONMENT']}"

          def get_signed_url(object_key):
              """
              Generate a signed URL for CloudFront access
              Args:
                  object_key (str): S3 object key of the song
              Returns:
                  str: Signed URL for CloudFront access
              """
              distribution_domain = os.environ['CLOUDFRONT_DOMAIN']
              url = f"https://{distribution_domain}/{object_key}"
              
              # Retrieve private key from SSM Parameter Store
              ssm = boto3.client('ssm')
              key_param = ssm.get_parameter(Name=os.environ['PRIVATE_KEY_PARAM'], WithDecryption=True)
              private_key = serialization.load_pem_private_key(
                  key_param['Parameter']['Value'].encode('utf-8'),
                  password=None,
                  backend=default_backend()
              )
              
              # Configure CloudFront signer with key pair ID
              key_id = os.environ['KEY_PAIR_ID']
              expire_date = datetime.utcnow() + timedelta(minutes=5)
              
              # Generate and return signed URL
              signer = CloudFrontSigner(key_id, private_key.sign_msg)
              signed_url = signer.generate_presigned_url(
                  url,
                  date_less_than=expire_date
              )
              
              return signed_url

          def handler(event, context):
              """
              Main Lambda handler to retrieve all songs in a given playlist
              Args:
                  event (dict): API Gateway event
                  context (object): Lambda context
              Returns:
                  dict: API Gateway response
              """
              try:
                  # Extract user information from Cognito claims
                  claims = event['requestContext']['authorizer']['claims']
                  user_id = claims['sub']
                  groups = claims.get('cognito:groups', [])
                  is_admin = 'admin' in groups

                  # Extract playlist ID from request body
                  body = json.loads(event['body'])
                  playlist_id = body.get('playlist_id')
                  if not playlist_id:
                      return {
                          'statusCode': 400,
                          'body': json.dumps('Playlist ID is required')
                      }

                  # Determine the prefix based on user permissions
                  prefix = f"playlists/{playlist_id}/" if is_admin else f"playlists/{user_id}/{playlist_id}/"
                  
                  # List all songs in the playlist
                  response = s3.list_objects_v2(Bucket=bucket_name, Prefix=prefix)
                  songs = []
                  
                  for obj in response.get('Contents', []):
                      song_key = obj['Key']
                      if song_key.endswith(('.wav', '.mp3', '.aac')):
                          signed_url = get_signed_url(song_key)
                          songs.append({
                              'name': song_key.split('/')[-1],
                              'url': signed_url
                          })
                  
                  return {
                      'statusCode': 200,
                      'body': json.dumps(songs)
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          CLOUDFRONT_DOMAIN: !GetAtt SongsDistribution.DomainName
          PRIVATE_KEY_PARAM: !Sub /cloudfront/${Environment}/private-key
          KEY_PAIR_ID: !Ref CloudFrontKeyPairId

  # IAM role for the Lambda function
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaS3Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject  # Allow Lambda to put objects in S3
                Resource: !Sub arn:aws:s3:::${SongsBucket}/*  # S3 bucket ARN
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                Resource: !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}

  # IAM role for playlist management Lambda
  PlaylistLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: PlaylistS3AndRedshiftPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:GetObject
                Resource: 
                  - !Sub arn:aws:s3:::${SongsBucket}
                  - !Sub arn:aws:s3:::${SongsBucket}/*
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                Resource: !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}

  # IAM role for SignedUrlLambda
  SignedUrlLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: SSMAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                Resource: !Sub arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/cloudfront/${Environment}/*

  # IAM role for RetrieveSongsLambda
  RetrieveSongsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: RetrieveSongsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:GetObject
                Resource: 
                  - !Sub arn:aws:s3:::${SongsBucket}
                  - !Sub arn:aws:s3:::${SongsBucket}/*
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                Resource: !Sub arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/cloudfront/${Environment}/*

  # Redshift cluster for data storage
  RedshiftCluster:
    DependsOn: RedshiftSecurityGroup
    Type: AWS::Redshift::Cluster
    Properties:
      ClusterIdentifier: !Sub ayauplay-cluster-${Environment}
      DBName: ayauplaydb
      MasterUsername: !Ref RedshiftMasterUsername
      MasterUserPassword: !Ref RedshiftMasterPassword
      NodeType: dc2.large
      NumberOfNodes: 2
      ClusterType: multi-node
      PubliclyAccessible: false
      ClusterSubnetGroupName: !Ref RedshiftSubnetGroup
      VpcSecurityGroupIds: 
        - !GetAtt RedshiftSecurityGroup.GroupId
      IamRoles:
        - !GetAtt RedshiftRole.Arn

  # Security group for Redshift cluster
  RedshiftSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Redshift cluster
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5439
          ToPort: 5439
          CidrIp: !Ref VpcCidr
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  # Redshift cluster subnet group
  RedshiftSubnetGroup:
    Type: AWS::Redshift::ClusterSubnetGroup
    Properties:
      Description: Subnet group for Redshift cluster
      SubnetIds: !Ref RedshiftSubnets

  # IAM role for Redshift
  RedshiftRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: redshift.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess

  # Lambda function to initialize Redshift tables
  RedshiftInitLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub RedshiftInit-${Environment}
      Handler: index.handler
      Role: !GetAtt RedshiftInitRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import time
          import logging

          # Set up logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          redshift_data = boto3.client('redshift-data')
          
          def execute_sql(sql, database, cluster_id, db_user):
              logger.info(f"Executing SQL on cluster: {cluster_id}, database: {database}")
              try:
                  # Execute the SQL statement
                  response = redshift_data.execute_statement(
                      Database=database,
                      ClusterIdentifier=cluster_id,
                      DbUser=db_user,
                      Sql=sql
                  )
                  statement_id = response['Id']
                  
                  # Wait for the statement to complete
                  while True:
                      status = redshift_data.describe_statement(Id=statement_id)
                      if status['Status'] in ['FINISHED', 'FAILED', 'ABORTED']:
                          if status['Status'] != 'FINISHED':
                              error_message = status.get('Error', 'Unknown error')
                              raise Exception(f"SQL execution failed: {error_message}")
                          break
                      time.sleep(2)
                  
                  return statement_id
              except Exception as e:
                  logger.error(f"Error executing SQL: {str(e)}")
                  raise
          
          def handler(event, context):
              logger.info(f"Event received: {json.dumps(event)}")
              response_data = {}
              
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      cluster_id = event['ResourceProperties']['ClusterId']
                      database = event['ResourceProperties']['Database']
                      db_user = event['ResourceProperties']['DbUser']
                      
                      # Define table creation SQL statements - execute one at a time
                      sql_statements = [
                          # Create the database if it doesn't exist
                          """
                          CREATE DATABASE ayauplaydb;
                          """,
                          """
                          CREATE TABLE IF NOT EXISTS playlists (
                              playlist_id VARCHAR(255) PRIMARY KEY,
                              name VARCHAR(255) NOT NULL,
                              description VARCHAR(255),
                              created_at TIMESTAMP DEFAULT GETDATE(),
                              updated_at TIMESTAMP DEFAULT GETDATE()
                          );
                          """,
                          """
                          CREATE TABLE IF NOT EXISTS songs (
                              song_id VARCHAR(255) PRIMARY KEY,
                              title VARCHAR(255) NOT NULL,
                              author VARCHAR(255) NOT NULL,
                              performer VARCHAR(255) NOT NULL,
                              ISRC VARCHAR(255) NOT NULL,
                              IPI BIGINT NOT NULL,
                              code BIGINT NOT NULL,
                              duration INTEGER,
                              s3_key VARCHAR(512) NOT NULL,
                              art_location VARCHAR(512),
                              uploaded_at TIMESTAMP DEFAULT GETDATE()
                          );
                          """,
                          """
                          CREATE TABLE IF NOT EXISTS playlist_songs (
                              playlist_id VARCHAR(255) REFERENCES playlists(playlist_id),
                              song_id VARCHAR(255) REFERENCES songs(song_id),
                              added_at TIMESTAMP DEFAULT GETDATE(),
                              PRIMARY KEY (playlist_id, song_id)
                          );
                          """,
                          """
                          CREATE TABLE IF NOT EXISTS stream_analytics (
                              stream_id VARCHAR(255) PRIMARY KEY,
                              song_id VARCHAR(255) REFERENCES songs(song_id),
                              user_id VARCHAR(255),
                              stream_duration INTEGER,
                              streamed_at TIMESTAMP DEFAULT GETDATE()
                          );
                          """,
                          """
                          CREATE TABLE IF NOT EXISTS playlist_permissions (
                              permission_id VARCHAR(255) PRIMARY KEY,
                              user_id VARCHAR(255),
                              playlist_id VARCHAR(255) REFERENCES playlists(playlist_id),
                              granted_at TIMESTAMP DEFAULT GETDATE()
                          );
                          """,
                          # Insert sample data for playlists
                          """
                          INSERT INTO playlists (playlist_id, name, description, created_at, updated_at)
                          VALUES 
                          ('playlist1', 'Playlist 1', 'Description for Playlist 1', GETDATE(), GETDATE()),
                          ('playlist2', 'Playlist 2', 'Description for Playlist 2', GETDATE(), GETDATE()),
                          ('playlist3', 'Playlist 3', 'Description for Playlist 3', GETDATE(), GETDATE());
                          """,
                          # Insert sample data for songs
                          """
                          INSERT INTO songs (song_id, title, author, performer, ISRC, IPI, code, duration, s3_key, art_location, uploaded_at)
                          VALUES 
                          ('song1', 'QVAH', 'Alejandro Miño', 'NOSOY', 'QZ5AB2142443', 1161026108, 12319328, 0, 's3://songs-bucket-dev/03 Qvah 1.1 MTLK 4416.wav', '', GETDATE()),
                          ('song2', 'YANÓ', 'Alejandro Miño', 'NOSOY', 'DGA062238445', 23456, 234567, 0, 's3://songs-bucket-dev/02 Yanó 1.0 MTLK 4416.wav', '', GETDATE()),
                          ('song3', 'ZEN', 'Alejandro Miño', 'NOSOY', 'DGA489238945', 2345672, 23456781, 0, 's3://songs-bucket-dev/04 Zen 1.0 MTLK 4416.wav', '', GETDATE());
                          """,
                          # Insert sample data for playlist_songs
                          """
                          INSERT INTO playlist_songs (playlist_id, song_id, added_at)
                          VALUES 
                          ('playlist1', 'song1', GETDATE()),
                          ('playlist2', 'song2', GETDATE()),
                          ('playlist3', 'song3', GETDATE());
                          """,
                          # Insert permissions for the specified user ID
                          """
                          INSERT INTO playlist_permissions (permission_id, user_id, playlist_id, granted_at)
                          VALUES 
                          ('perm1', 'c4489488-e081-7001-f0b1-6184251f36a5', 'playlist1', GETDATE()),
                          ('perm2', 'c4489488-e081-7001-f0b1-6184251f36a5', 'playlist2', GETDATE()),
                          ('perm3', 'c4489488-e081-7001-f0b1-6184251f36a5', 'playlist3', GETDATE());
                          """
                      ]
                      
                      # Execute each statement separately
                      for sql in sql_statements:
                          statement_id = execute_sql(sql.strip(), database, cluster_id, db_user)
                          logger.info(f"Successfully executed statement: {statement_id}")
                      
                      response_data['Message'] = 'Database initialized successfully'
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  else:
                      response_data['Message'] = 'No action required for DELETE'
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                      
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  response_data['Error'] = str(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)
      Runtime: python3.8
      Timeout: 300
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment

  # IAM role for RedshiftInit Lambda
  RedshiftInitRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: RedshiftDataAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                Resource: '*'  # Redshift Data API requires '*' for these actions
              - Effect: Allow
                Action:
                  - redshift:GetClusterCredentials
                  - redshift:DescribeClusters
                Resource: 
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbuser:${RedshiftCluster}/*
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbname:${RedshiftCluster}/*

  # Custom resource to trigger database initialization
  RedshiftInitTrigger:
    Type: Custom::RedshiftInit
    DependsOn: RedshiftCluster
    Properties:
      ServiceToken: !GetAtt RedshiftInitLambda.Arn
      ClusterId: !Sub ayauplay-cluster-${Environment}
      Database: ayauplaydb
      DbUser: !Ref RedshiftMasterUsername

  # Lambda function to record streaming data
  RecordStreamLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub RecordStreamLambda-${Environment}
      Handler: index.handler
      Role: !GetAtt RecordStreamLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          import os

          redshift_data = boto3.client('redshift-data')

          def handler(event, context):
              try:
                  body = json.loads(event['body'])
                  song_id = body['song_id']
                  stream_duration = body['stream_duration']

                  # Extract user information from Cognito claims
                  claims = event['requestContext']['authorizer']['claims']
                  user_id = claims['sub']

                  sql = f"""
                  INSERT INTO stream_analytics (stream_id, song_id, user_id, stream_duration, streamed_at)
                  VALUES ('{uuid.uuid4()}', '{song_id}', '{user_id}', {stream_duration}, GETDATE());
                  """

                  response = redshift_data.execute_statement(
                      ClusterIdentifier=os.environ['REDSHIFT_CLUSTER_ID'],
                      Database=os.environ['REDSHIFT_DATABASE'],
                      DbUser=os.environ['REDSHIFT_DB_USER'],
                      Sql=sql
                  )

                  return {
                      'statusCode': 200,
                      'body': json.dumps('Stream data recorded successfully')
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'body': json.dumps(f'Error: {str(e)}')
                  }
      Runtime: python3.8
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          REDSHIFT_CLUSTER_ID: !Sub ayauplay-cluster-${Environment}
          REDSHIFT_DATABASE: ayauplaydb
          REDSHIFT_DB_USER: !Ref RedshiftMasterUsername

  # IAM role for RecordStreamLambda
  RecordStreamLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: RedshiftDataAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                Resource: '*'  # Redshift Data API requires '*' for these actions
              - Effect: Allow
                Action:
                  - redshift:GetClusterCredentials
                  - redshift:DescribeClusters
                Resource: 
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbuser:${RedshiftCluster}/*
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbname:${RedshiftCluster}/*

  # API Gateway resource for the record stream endpoint
  RecordStreamResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: record-stream
      RestApiId: !Ref ApiGateway

  # API Gateway method for the record stream endpoint
  RecordStreamMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: ApiGatewayAuthorizer
    Properties:
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref ApiGatewayAuthorizer
      HttpMethod: POST
      ResourceId: !Ref RecordStreamResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'http://localhost:5173'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Credentials: "'true'"
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RecordStreamLambda.Arn}/invocations
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Credentials: true

  # Permission for API Gateway to invoke the RecordStreamLambda function
  RecordStreamLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt RecordStreamLambda.Arn
      Principal: apigateway.amazonaws.com

  # API Gateway to expose the Lambda function
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub UploadSongsApi-${Environment}  # Name of the API Gateway

  # API Gateway resource for the upload endpoint
  ApiGatewayResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId  # Root resource ID
      PathPart: upload  # Path part for the resource
      RestApiId: !Ref ApiGateway  # Reference to the API Gateway

  # API Gateway method for the upload endpoint
  ApiGatewayMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: ApiGatewayAuthorizer
    Properties:
      AuthorizationType: COGNITO_USER_POOLS  # Use Cognito user pools for authorization
      AuthorizerId: !Ref ApiGatewayAuthorizer  # Reference to the authorizer
      HttpMethod: POST  # HTTP method
      ResourceId: !Ref ApiGatewayResource  # Reference to the resource
      RestApiId: !Ref ApiGateway  # Reference to the API Gateway
      Integration:
        IntegrationHttpMethod: POST  # HTTP method for integration
        Type: AWS_PROXY  # Use AWS_PROXY integration type
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt UploadSongsLambda.Arn  # Lambda function ARN
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'http://localhost:5173'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Credentials: "'true'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Credentials: true

  # Defines the /playlists resource endpoint in API Gateway
  # This resource handles all playlist-related operations
  PlaylistResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      # Set this resource as a child of the API's root path
      ParentId: !GetAtt ApiGateway.RootResourceId
      # Creates the /playlists path segment
      PathPart: playlists
      RestApiId: !Ref ApiGateway

  # Configures the GET method for the /playlists endpoint
  # This endpoint supports:
  # - Listing all playlists: GET /playlists
  # - Getting songs in a playlist: GET /playlists?playlist=<playlist_name>
  PlaylistGetMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: ApiGatewayAuthorizer
    Properties:
      # Requires authentication via Cognito User Pools
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref ApiGatewayAuthorizer
      HttpMethod: GET
      ResourceId: !Ref PlaylistResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'http://localhost:5173'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Credentials: "'true'"
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt PlaylistManagementLambda.Arn
      # Configures the optional 'playlist' query parameter
      # When present, it retrieves songs from a specific playlist
      # When absent, it lists all available playlists
      RequestParameters:
        method.request.querystring.playlist: false
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Credentials: true

  # API Gateway resource for the retrieve songs endpoint
  RetrieveSongsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: retrieve-songs
      RestApiId: !Ref ApiGateway

  # API Gateway method for the retrieve songs endpoint
  RetrieveSongsMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: ApiGatewayAuthorizer
    Properties:
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref ApiGatewayAuthorizer
      HttpMethod: POST
      ResourceId: !Ref RetrieveSongsResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt RetrieveSongsLambda.Arn
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'http://localhost:5173'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST,OPTIONS'"
              method.response.header.Access-Control-Allow-Credentials: "'true'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Credentials: true

  # Permission for API Gateway to invoke the RetrieveSongsLambda function
  RetrieveSongsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt RetrieveSongsLambda.Arn
      Principal: apigateway.amazonaws.com

  # Cognito User Pools Authorizer configuration
  # This authorizer validates JWT tokens issued by Cognito
  # and ensures only authenticated users can access the API
  ApiGatewayAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      # Friendly name for the authorizer
      Name: CognitoAuthorizer
      # Specifies where to look for the JWT token in incoming requests
      # The token should be provided in the Authorization header
      IdentitySource: method.request.header.Authorization
      RestApiId: !Ref ApiGateway
      # Configures this as a Cognito User Pools authorizer
      Type: COGNITO_USER_POOLS
      # Links this authorizer to the Cognito User Pool
      ProviderARNs:
        - !GetAtt UserPool.Arn

  # Permission for API Gateway to invoke the Lambda function
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction  # Allow invocation of the Lambda function
      FunctionName: !GetAtt UploadSongsLambda.Arn  # Lambda function ARN
      Principal: apigateway.amazonaws.com  # Principal for API Gateway

  PlaylistLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt PlaylistManagementLambda.Arn
      Principal: apigateway.amazonaws.com

  # Create a user pool client for authentication
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref UserPool
      ClientName: !Sub UserPoolClient-${Environment}
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH

  # WAF WebACL to protect the API Gateway
  WAFWebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: !Sub WebACL-${Environment}  # Name of the WebACL
      Scope: REGIONAL  # Scope of the WebACL
      DefaultAction:
        Allow: {}  # Default action is to allow requests
      VisibilityConfig:
        SampledRequestsEnabled: true  # Enable sampling of requests
        CloudWatchMetricsEnabled: true  # Enable CloudWatch metrics
        MetricName: !Sub WebACL-${Environment}  # Metric name
      Rules:
        - Name: AllowLocalhostDev
          Priority: 0  # Highest priority
          Action:
            Allow: {}
          Statement:
            OrStatement:
              Statements:
                - ByteMatchStatement:
                    SearchString: 'http://localhost:5173'
                    FieldToMatch:
                      SingleHeader:
                        Name: origin
                    TextTransformations:
                      - Priority: 1
                        Type: NONE
                    PositionalConstraint: EXACTLY
                - ByteMatchStatement:
                    SearchString: 'localhost:5173'
                    FieldToMatch:
                      SingleHeader:
                        Name: origin
                    TextTransformations:
                      - Priority: 1
                        Type: NONE
                    PositionalConstraint: CONTAINS
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AllowLocalhostDev

        # Rate limiting rule to prevent DDoS attacks
        - Name: RateLimitRule
          Priority: 1
          Action:
            Block: {}
          Statement:
            RateBasedStatement:
              Limit: 100  # Limit to 100 requests per 5 minutes
              AggregateKeyType: IP  # Aggregate by IP address
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: RateLimitRule
            
        # Rule to block requests with body size greater than 50MB
        - Name: MaxFileSize
          Priority: 2
          Action:
            Block: {}
          Statement:
            SizeConstraintStatement:
              ComparisonOperator: GT
              Size: 52428800  # 50MB max file size
              FieldToMatch:
                Body: {}
              TextTransformations:
                - Type: NONE
                  Priority: 1
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: MaxFileSize

        # Content type validation for audio files
        - Name: AudioFilesOnly
          Priority: 3
          Action:
            Block: {}
          Statement:
            OrStatement:
              Statements:
                - ByteMatchStatement:
                    SearchString: audio/wav
                    FieldToMatch:
                      SingleHeader:
                        Name: content-type
                    TextTransformations:
                      - Priority: 1
                        Type: LOWERCASE
                    PositionalConstraint: EXACTLY
                - ByteMatchStatement:
                    SearchString: audio/mpeg
                    FieldToMatch:
                      SingleHeader:
                        Name: content-type
                    TextTransformations:
                      - Priority: 1
                        Type: LOWERCASE
                    PositionalConstraint: EXACTLY
                - ByteMatchStatement:
                    SearchString: audio/aac
                    FieldToMatch:
                      SingleHeader:
                        Name: content-type
                    TextTransformations:
                      - Priority: 1
                        Type: LOWERCASE
                    PositionalConstraint: EXACTLY
                - ByteMatchStatement:
                    SearchString: multipart/form-data
                    FieldToMatch:
                      SingleHeader:
                        Name: content-type
                    TextTransformations:
                      - Priority: 1
                        Type: LOWERCASE
                    PositionalConstraint: CONTAINS
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AudioFilesOnly

        # AWS managed rule group for common security threats
        - Name: AWS-AWSManagedRulesCommonRuleSet
          Priority: 4
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSManagedRulesCommonRuleSet

        # AWS managed rule group for known bad inputs
        - Name: AWS-AWSManagedRulesKnownBadInputsRuleSet
          Priority: 5
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesKnownBadInputsRuleSet
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSManagedRulesKnownBadInputsRuleSet

        # AWS managed rule group for SQL injection protection
        - Name: AWS-AWSManagedRulesSQLiRuleSet
          Priority: 6
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesSQLiRuleSet
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSManagedRulesSQLiRuleSet

  # API Gateway deployment configuration
  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: 
      - ApiGatewayAuthorizer
      - UserPoolClient
      - ApiGatewayMethod
      - PlaylistGetMethod
      - RetrieveSongsMethod
      - RecordStreamMethod
    Properties:
      RestApiId: !Ref ApiGateway

  # API Gateway stage configuration
  ApiGatewayStage:
    Type: AWS::ApiGateway::Stage
    DependsOn: ApiGatewayDeployment
    Properties:
      DeploymentId: !Ref ApiGatewayDeployment
      RestApiId: !Ref ApiGateway
      StageName: !Ref Environment

  # WAF WebACL association with the API Gateway stage
  WAFWebACLAssociation:
    Type: AWS::WAFv2::WebACLAssociation
    Properties:
      ResourceArn: !Sub arn:aws:apigateway:${AWS::Region}:${AWS::AccountId}:/restapis/${ApiGateway}/stages/${Environment}
      WebACLArn: !GetAtt WAFWebACL.Arn
    DependsOn:
      - ApiGatewayStage

Conditions:
  IsDev:
    Fn::Equals:
      - !Ref Environment
      - dev

Outputs:
  # Output the URL for the API Gateway
  ApiGatewayUrl:
    Description: URL for the API Gateway
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/upload

  PlaylistApiUrl:
    Description: URL for the Playlist API Gateway
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/playlists

  RetrieveSongsApiUrl:
    Description: URL for the Retrieve Songs API Gateway
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/retrieve-songs

  CloudFrontDomain:
    Description: CloudFront Distribution Domain Name
    Value: !GetAtt SongsDistribution.DomainName

  RedshiftClusterEndpoint:
    Description: Endpoint for Redshift cluster
    Value: !Sub ${RedshiftCluster.Endpoint.Address}:${RedshiftCluster.Endpoint.Port}