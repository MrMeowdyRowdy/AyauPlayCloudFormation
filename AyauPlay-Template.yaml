AWSTemplateFormatVersion: '2010-09-09'

Parameters:
  Environment:
    Type: String
    Description: The environment in which this stack is deployed (e.g., dev, prod)
    AllowedValues:
      - dev
      - prod
    Default: prod
  CloudFrontKeyPairId:
    Type: String
    Description: The ID of the CloudFront key pair used for signed URLs
    Default: K3TECQ27MFZFW
  RedshiftMasterUsername:
    Type: String
    Description: Master username for Redshift cluster
    Default: admin
    MinLength: 1
    MaxLength: 128
    AllowedPattern: '([a-z])([a-z]|[0-9])*'
  RedshiftMasterPassword:
    Type: String
    Description: Master password for Redshift cluster (must contain at least 8 characters, including uppercase, lowercase, numbers, and special characters)
    NoEcho: true
    MinLength: 8
    MaxLength: 64
    Default: 'Ay47P1a74py2024!-*#'
    AllowedPattern: ^(?=.*[A-Z])(?=.*[a-z])(?=.*\d)(?=.*[@#$%^&+=!]).*$
    ConstraintDescription: Must be at least 8 characters containing at least one uppercase letter, one lowercase letter, one number, and one special character (@#$%^&+=!)
  VpcId:
    Type: AWS::EC2::VPC::Id
    Description: VPC ID where Redshift cluster will be deployed
    Default: vpc-0b4228448dcd82f4d
  RedshiftSubnets:
    Type: List<AWS::EC2::Subnet::Id>
    Description: List of subnet IDs for Redshift cluster
    Default: >-
      subnet-0098ced055bf20380,subnet-06cbeea76c0113820,subnet-0243375a1f089435e,subnet-055f6bbceddc8c7ec,subnet-04ddb80a25000f797,subnet-0c24f5e04569b6916
  VpcCidr:
    Type: String
    Description: CIDR block for VPC (e.g., 10.0.0.0/16)
    Default: 172.31.0.0/16
    AllowedPattern: ^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$

Resources:
  # Cognito User Pool for user authentication
  UserPool:
    Type: AWS::Cognito::UserPool
    Properties:
      UserPoolName: !Sub UserPool-${Environment}  # Name of the user pool
      AliasAttributes:
        - preferred_username
        - email
      Policies:
        PasswordPolicy:
          MinimumLength: 8  # Minimum password length
          RequireUppercase: true  # Require at least one uppercase letter
          RequireLowercase: true  # Require at least one lowercase letter
          RequireNumbers: true  # Require at least one number
          RequireSymbols: true  # Require at least one symbol
      AutoVerifiedAttributes:
        - email  # Automatically verify email addresses
      Schema:
        - Name: email
          Required: true  # Email is required
          Mutable: true  # Email can be updated
      AdminCreateUserConfig:
        AllowAdminCreateUserOnly: true  # Only admins can create users

  # Admin group with elevated permissions
  AdminGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      GroupName: admin  # Name of the group
      UserPoolId: !Ref UserPool  # Reference to the user pool
      Description: Admin group with elevated permissions

  # Client group with standard permissions
  ClientGroup:
    Type: AWS::Cognito::UserPoolGroup
    Properties:
      GroupName: client  # Name of the group
      UserPoolId: !Ref UserPool  # Reference to the user pool
      Description: Client group with standard permissions

  # S3 bucket to store uploaded songs
  SongsBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub songs-bucket-${Environment}  # Name of the S3 bucket
      CorsConfiguration:
        CorsRules:
          - AllowedHeaders: ['*']
            AllowedMethods: [GET, PUT, POST, DELETE]
            AllowedOrigins:
              - !If
                - IsDev
                - 'http://localhost:5173'
                - '*'
            MaxAge: 3000

  # CloudFront Origin Access Control
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub OAC-songs-${Environment}
        Description: Origin Access Control for Songs Bucket
        SigningProtocol: sigv4
        SigningBehavior: always
        OriginAccessControlOriginType: s3

  # CloudFront response headers policy for CORS
  CloudFrontResponseHeadersPolicy:
    Type: AWS::CloudFront::ResponseHeadersPolicy
    Properties:
      ResponseHeadersPolicyConfig:
        Name: !Sub CORSPolicy-${Environment}
        CorsConfig:
          AccessControlAllowCredentials: false
          AccessControlAllowHeaders:
            Items:
              - Content-Type
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - Access-Control-Allow-Origin
          AccessControlAllowMethods:
            Items:
              - GET
              - HEAD
              - OPTIONS
              - PUT
              - PATCH
              - POST
              - DELETE
          AccessControlAllowOrigins:
            Items:
              - 'https://ayauplay.ayaumusic.com'
          AccessControlExposeHeaders:
            Items:
              - Content-Type
              - X-Amz-Date
              - Authorization
              - X-Api-Key
              - X-Amz-Security-Token
              - Access-Control-Allow-Origin
          AccessControlMaxAgeSec: 600
          OriginOverride: false

  # CloudFront distribution for song streaming
  SongsDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: ''
        Origins:
          - DomainName: !GetAtt SongsBucket.RegionalDomainName
            Id: S3Origin
            S3OriginConfig:
              OriginAccessIdentity: ''
            OriginAccessControlId: !GetAtt CloudFrontOriginAccessControl.Id
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: https-only
          TrustedSigners:
            - self
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
            - OPTIONS
          ForwardedValues:
            QueryString: false
            Cookies:
              Forward: none
          ResponseHeadersPolicyId: !Ref CloudFrontResponseHeadersPolicy

  # Update S3 bucket policy to allow CloudFront access
  SongsBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref SongsBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub ${SongsBucket.Arn}/*
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${SongsDistribution.Id}

  # Lambda function to handle song uploads
  UploadSongsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub UploadSongsLambda-${Environment}  # Name of the Lambda function
      Handler: index.handler  # Handler method
      Role: !GetAtt LambdaExecutionRole.Arn  # IAM role for the Lambda function
      Code:
        ZipFile: |
          import json
          import boto3
          import base64
          import os
          import uuid

          # Initialize S3 and Redshift clients
          s3 = boto3.client('s3')
          redshift_data = boto3.client('redshift-data')

          # Define allowed audio file extensions and their MIME types
          ALLOWED_EXTENSIONS = {'.wav', '.mp3', '.aac'}
          CONTENT_TYPES = {
              '.wav': 'audio/wav',
              '.mp3': 'audio/mpeg',
              '.aac': 'audio/aac'
          }

          def is_valid_audio(filename):
              """
              Check if the file has an allowed audio extension
              Args:
                  filename (str): Name of the file to check
              Returns:
                  bool: True if extension is allowed, False otherwise
              """
              ext = os.path.splitext(filename)[1].lower()
              return ext in ALLOWED_EXTENSIONS

          def get_content_type(filename):
              """
              Get the MIME type for a file based on its extension
              Args:
                  filename (str): Name of the file
              Returns:
                  str: MIME type of the file or default octet-stream
              """
              ext = os.path.splitext(filename)[1].lower()
              return CONTENT_TYPES.get(ext, 'application/octet-stream')

          def handler(event, context):
              """
              Main Lambda handler for file uploads
              Args:
                  event (dict): API Gateway event
                  context (object): Lambda context
              Returns:
                  dict: API Gateway response
              """
              try:
                  # Parse the request body and decode the file
                  body = json.loads(event['body'])
                  file_content = base64.b64decode(body['file'])
                  file_name = body['fileName']
                  title = body['title']
                  author = body['author']
                  performer = body['performer']
                  ISRC = body['ISRC']
                  ISWC = body['ISWC']
                  IPI = body['IPI']
                  code = body['code']
                  duration = body.get('duration', 0)
                  s3_artkey = body.get('s3_artkey', '')

                  # Validate file type
                  if not is_valid_audio(file_name):
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Access-Control-Allow-Headers': 'Content-Type',
                              'Access-Control-Allow-Origin': 'https://ayauplay.ayaumusic.com',
                              'Access-Control-Allow-Methods': 'OPTIONS,POST'
                          },
                          'body': json.dumps('Only .wav, .mp3, and .aac files are allowed')
                      }

                  # Get the environment-specific bucket name
                  bucket_name = f"songs-bucket-{os.environ['ENVIRONMENT']}"
                  
                  # Generate a unique key for the S3 object
                  s3_key = f"{uuid.uuid4()}_{file_name}"
                  
                  # Upload file to S3 with proper content type
                  s3.put_object(
                      Bucket=bucket_name,
                      Key=s3_key,
                      Body=file_content,
                      ContentType=get_content_type(file_name)
                  )

                  # Extract user information from Cognito claims
                  claims = event['requestContext']['authorizer']['claims']
                  uploaded_by = claims['sub']

                  # Insert song details into the database
                  sql = f"""
                  INSERT INTO songs (song_id, title, author, performer, ISRC, IPI, code, duration, s3_key, s3_artkey, uploaded_by, uploaded_at)
                  VALUES ('{uuid.uuid4()}', '{title}', '{author}', '{performer}', '{ISRC}', {IPI}, {code}, {duration}, '{s3_key}', '{s3_artkey}', '{uploaded_by}', GETDATE());
                  """
                  redshift_data.execute_statement(
                      ClusterIdentifier=os.environ['REDSHIFT_CLUSTER_ID'],
                      Database=os.environ['REDSHIFT_DATABASE'],
                      DbUser=os.environ['REDSHIFT_DB_USER'],
                      Sql=sql
                  )

                  return {
                      'statusCode': 200,
                      'headers': {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,POST"
                      },
                      'body': json.dumps('File uploaded and song details stored successfully')
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'headers': {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,POST"
                      },
                      'body': json.dumps(f'Error: {str(e)}')
                  }
      Runtime: python3.10  # Runtime environment
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          REDSHIFT_CLUSTER_ID: !Sub ayauplay-cluster-${Environment}
          REDSHIFT_DATABASE: ayauplaydb
          REDSHIFT_DB_USER: !Ref RedshiftMasterUsername

  # Lambda for playlist management
  PlaylistManagementLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub PlaylistManagementLambda-${Environment}
      Handler: index.handler
      Role: !GetAtt PlaylistLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging

          # Initialize Redshift Data API client
          redshift_data = boto3.client('redshift-data')

          # Set up logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def list_user_playlists(user_id):
              """
              Retrieve registries from the playlist_permissions table where user_id matches.
              Args:
                  user_id (str): Cognito user ID
              Returns:
                  dict: List of matching registries.
              """
              try:
                  # SQL query to fetch matching registries
                  sql = f"""
                  SELECT pp.permission_id, pp.user_id, pp.playlist_id, p.name, '' AS s3_artkey
                  FROM playlist_permissions pp
                  INNER JOIN playlists p
                  ON pp.playlist_id = p.playlist_id
                  WHERE pp.user_id = '{user_id}'
                  """
                  logger.info(f"Executing SQL query: {sql}")

                  # Execute the query
                  response = redshift_data.execute_statement(
                      ClusterIdentifier=os.environ['REDSHIFT_CLUSTER_ID'],
                      Database=os.environ['REDSHIFT_DATABASE'],
                      DbUser=os.environ['REDSHIFT_DB_USER'],
                      Sql=sql
                  )
                  logger.info(f"Query execution response: {response}")

                  # Extract records from the response
                  statement_id = response['Id']
                  logger.info(f"Statement ID: {statement_id}")

                  # Wait for the query to complete and fetch results
                  while True:
                      status = redshift_data.describe_statement(Id=statement_id)
                      logger.info(f"Query status: {status['Status']}")
                      if status['Status'] in ['FINISHED', 'FAILED', 'ABORTED']:
                          if status['Status'] != 'FINISHED':
                              error_message = status.get('Error', 'Unknown error')
                              logger.error(f"SQL execution failed: {error_message}")
                              raise Exception(f"SQL execution failed: {error_message}")
                          break

                  # Fetch the results
                  results = redshift_data.get_statement_result(Id=statement_id)
                  logger.info(f"Query results: {results}")

                  records = results.get('Records', [])
                  playlists = [
                      {
                          "permission_id": record[0]['stringValue'],
                          "user_id": record[1]['stringValue'],
                          "playlist_id": record[2]['stringValue'],
                          "name": record[3]['stringValue'],
                          "s3_artkey": record[4]['stringValue']
                      }
                      for record in records
                  ]

                  logger.info(f"Playlists retrieved: {playlists}")

                  return {
                      "statusCode": 200,
                      "headers": {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,GET"
                      },
                      "body": json.dumps({
                          "user_id": user_id,
                          "playlists": playlists
                      })
                  }
              except Exception as e:
                  logger.error(f"Error in list_user_playlists: {str(e)}")
                  return {
                      "statusCode": 500,
                      "headers": {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,GET"
                      },
                      "body": json.dumps(f"Error: {str(e)}")
                  }

          def handler(event, context):
              """
              Main Lambda handler for playlist operations.
              Args:
                  event (dict): API Gateway event
                  context (object): Lambda context
              Returns:
                  dict: API Gateway response
              """
              try:
                  # Extract user information from Cognito claims
                  claims = event['requestContext']['authorizer']['claims']
                  user_id = claims['sub']  # Use the Cognito sub as user_id
                  logger.info(f"Received request from user_id: {user_id}")

                  # Call the function to list user playlists
                  return list_user_playlists(user_id)
              except Exception as e:
                  logger.error(f"Error in handler: {str(e)}")
                  return {
                      "statusCode": 500,
                      "headers": {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,GET"
                      },
                      "body": json.dumps(f"Error: {str(e)}")
                  }
      Runtime: python3.10
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          SIGNED_URL_LAMBDA: !Ref SignedUrlLambda
          REDSHIFT_CLUSTER_ID: !Sub ayauplay-cluster-${Environment}
          REDSHIFT_DATABASE: ayauplaydb
          REDSHIFT_DB_USER: !Ref RedshiftMasterUsername

  # Lambda for generating signed URLs
  SignedUrlLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub SignedUrlLambda-${Environment}
      Handler: index.handler
      Role: !GetAtt SignedUrlLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import os
          import logging
          import datetime
          import base64
          import boto3
          from cryptography.hazmat.primitives import hashes
          from cryptography.hazmat.primitives.asymmetric import padding
          from cryptography.hazmat.primitives.serialization import load_pem_private_key
          from cryptography.hazmat.backends import default_backend
          from botocore.signers import CloudFrontSigner
          from typing import Tuple, Optional

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          distribution_domain = os.environ['CLOUDFRONT_DOMAIN']
          key_pair_id = os.environ['KEY_PAIR_ID']
          expiry_in_hours = 8.0

          ssm = boto3.client('ssm')

          def rsa_signer(message):
              private_key_param = os.environ['PRIVATE_KEY_PARAM']
              logger.info(f"private_key_param: {private_key_param}")

              try:
                key_param = ssm.get_parameter(Name=private_key_param, WithDecryption=True)
                private_key_pem = key_param['Parameter']['Value'].encode('utf-8')
                private_key = load_pem_private_key(private_key_pem, password=None, backend=default_backend())
                logger.info("Successfully retrieved private key from SSM")
              except Exception as e:
                logger.error(f"Error retrieving private key: {str(e)}")
                logger.error(traceback.format_exc())
                return None
              
              signature = private_key.sign(
                message,
                padding.PKCS1v15(),
                hashes.SHA1()
              )

              return signature


          def get_signed_url(cloudfront_url: str) -> Tuple[Optional[str], Optional[int]]:

              cf_signer = CloudFrontSigner(key_pair_id, rsa_signer)

              if cf_signer != None:
                current_datetime = datetime.datetime.utcnow()
                less_than = current_datetime + datetime.timedelta(hours=expiry_in_hours)
                signed_url = cf_signer.generate_presigned_url(cloudfront_url, date_less_than=less_than)
                return signed_url
              
              return None


          def handler(event, context):

              if 'object_key' not in event:
                return {
                  'status': 400,
                  'message': "`object_key` is a required property"
                }

              object_key = event['object_key']
              cloudfront_url = f"https://{distribution_domain}/{object_key}"
              signed_url = get_signed_url(cloudfront_url)

              if signed_url == None:
                return {
                  'status': 500,
                  'message': 'Something went wrong'
                }

              print(f'Signed URL: {signed_url}')

              return {
                'status': 200,
                'signed_url': signed_url
              }
      Runtime: python3.10
      Environment:
        Variables:
          CLOUDFRONT_DOMAIN: !GetAtt SongsDistribution.DomainName
          PRIVATE_KEY_PARAM: PrivateKeyDistribution
          KEY_PAIR_ID: !Ref CloudFrontKeyPairId
      Layers:
      - !Sub arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:layer:cloudfront:3

  # Lambda function to retrieve all songs in a given playlist
  RetrieveSongsLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub RetrieveSongsLambda-${Environment}
      Handler: index.handler
      Role: !GetAtt RetrieveSongsLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          import traceback

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          redshift_data = boto3.client('redshift-data')
          ssm = boto3.client('ssm')
          lambda_client = boto3.client('lambda')

          def get_songs_from_playlist(playlist_id):
              try:
                  sql = f"""
                  SELECT s.title, s.author, s.performer, s.duration, s.s3_key, '' AS s3_artkey
                  FROM songs s
                  INNER JOIN playlist_songs ps ON s.song_id = ps.song_id
                  WHERE ps.playlist_id = '{playlist_id}'
                  ORDER BY ps.added_at ASC;
                  """
                  
                  logger.info(f"Executing SQL: {sql}")
                  response = redshift_data.execute_statement(
                      ClusterIdentifier=os.environ['REDSHIFT_CLUSTER_ID'],
                      Database=os.environ['REDSHIFT_DATABASE'],
                      DbUser=os.environ['REDSHIFT_DB_USER'],
                      Sql=sql
                  )
                  
                  statement_id = response['Id']
                  logger.info(f"Got statement ID: {statement_id}")
                  
                  while True:
                      status = redshift_data.describe_statement(Id=statement_id)
                      logger.info(f"Statement status: {status}")
                      if status['Status'] == 'FINISHED':
                          break
                      elif status['Status'] in ['FAILED', 'ABORTED']:
                          error = status.get('Error', 'Unknown error')
                          logger.error(f"Query failed: {error}")
                          raise Exception(f"Query failed: {error}")
                  
                  results = redshift_data.get_statement_result(Id=statement_id)
                  logger.info(f"Got results: {json.dumps(results)}")
                  
                  songs = []
                  for record in results.get('Records', []):
                      try:
                          s3_key = record[4]['stringValue']
                          res = lambda_client.invoke(
                              FunctionName=os.environ['SIGNED_URL_LAMBDA'],
                              InvocationType='RequestResponse',
                              Payload=json.dumps({
                                  'object_key': s3_key
                              })
                          )
                          res_payload = json.loads(res['Payload'].read())

                          url = ''
                          if res_payload['status'] == 200:
                              url = res_payload['signed_url']

                          songs.append({
                              "title": record[0]['stringValue'],
                              "author": record[1]['stringValue'],
                              "performer": record[2]['stringValue'],
                              "duration": record[3]['stringValue'],
                              "s3_artkey": record[4]['stringValue'],
                              "s3_key": s3_key,
                              "url": url
                          })
                      except Exception as e:
                          logger.error(f"Error processing record: {str(e)}")
                          logger.error(f"Record data: {record}")
                          continue
                  
                  return songs
                  
              except Exception as e:
                  logger.error(f"Database error: {str(e)}")
                  logger.error(traceback.format_exc())
                  raise

          def handler(event, context):
              try:
                  # Log incoming request
                  logger.info(f"Received event: {json.dumps(event)}")
                  
                  # Get playlist_id from query parameters
                  query_params = event.get('queryStringParameters', {})
                  if not query_params or 'playlist_id' not in query_params:
                      return {
                          'statusCode': 400,
                          'headers': {
                              'Content-Type': 'application/json',
                              'Access-Control-Allow-Origin': 'https://ayauplay.ayaumusic.com',
                              'Access-Control-Allow-Methods': 'GET,OPTIONS'
                          },
                          'body': json.dumps({'error': 'playlist_id is required'})
                      }
                  
                  playlist_id = query_params['playlist_id']
                  
                  # Get songs from playlist
                  songs = get_songs_from_playlist(playlist_id)
                  
                  # Return response
                  return {
                      'statusCode': 200,
                      'headers': {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,GET"
                      },
                      'body': json.dumps({
                          'playlist_id': playlist_id,
                          'songs': songs
                      })
                  }
                  
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  return {
                      'statusCode': 500,
                      'headers': {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,GET"
                      },
                      'body': json.dumps({'error': str(e)})
                  }
      Runtime: python3.10
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          REDSHIFT_CLUSTER_ID: !Sub ayauplay-cluster-${Environment}
          REDSHIFT_DATABASE: ayauplaydb
          REDSHIFT_DB_USER: !Ref RedshiftMasterUsername
          KEY_PAIR_ID: !Ref CloudFrontKeyPairId
          SIGNED_URL_LAMBDA: !Ref SignedUrlLambda
      MemorySize: 512
      Timeout: 30

  # IAM role for the Lambda function
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: LambdaS3Policy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject  # Allow Lambda to put objects in S3
                Resource: !Sub arn:aws:s3:::${SongsBucket}/*  # S3 bucket ARN
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                Resource: !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}

  # IAM role for playlist management Lambda
  PlaylistLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: PlaylistS3AndRedshiftPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:GetObject
                Resource: 
                  - !Sub arn:aws:s3:::${SongsBucket}
                  - !Sub arn:aws:s3:::${SongsBucket}/*
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                  - redshift-data:GetStatementResult
                  - lambda:InvokeFunction
                Resource: '*'  # Modified to use '*' for redshift-data actions
              - Effect: Allow
                Action:
                  - redshift:GetClusterCredentials
                  - redshift:DescribeClusters
                Resource: 
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbuser:${RedshiftCluster}/*
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbname:${RedshiftCluster}/*

  # IAM role for SignedUrlLambda
  SignedUrlLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: SSMAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                Resource: !Sub arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/*

  # IAM role for RetrieveSongsLambda
  RetrieveSongsLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole  # Add this line
      Policies:
        - PolicyName: RetrieveSongsPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:ListBucket
                  - s3:GetObject
                Resource: 
                  - !Sub arn:aws:s3:::${SongsBucket}
                  - !Sub arn:aws:s3:::${SongsBucket}/*
              - Effect: Allow
                Action:
                  - ssm:GetParameter
                Resource: !Sub arn:aws:ssm:${AWS::Region}:${AWS::AccountId}:parameter/PrivateKeyDistribution
              # Add Redshift Data API permissions
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                  - redshift-data:GetStatementResult
                  - lambda:InvokeFunction
                Resource: '*'
              - Effect: Allow
                Action:
                  - redshift:GetClusterCredentials
                Resource: 
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbuser:${RedshiftCluster}/*
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbname:${RedshiftCluster}/*

  # Redshift cluster for data storage
  RedshiftCluster:
    DependsOn: RedshiftSecurityGroup
    Type: AWS::Redshift::Cluster
    Properties:
      ClusterIdentifier: !Sub ayauplay-cluster-${Environment}
      DBName: ayauplaydb  # Ensure the database is created with this name
      MasterUsername: !Ref RedshiftMasterUsername
      MasterUserPassword: !Ref RedshiftMasterPassword
      NodeType: ra3.large
      NumberOfNodes: 1
      ClusterType: single-node
      PubliclyAccessible: false
      ClusterSubnetGroupName: !Ref RedshiftSubnetGroup
      VpcSecurityGroupIds: 
        - !GetAtt RedshiftSecurityGroup.GroupId
      IamRoles:
        - !GetAtt RedshiftRole.Arn

  # Security group for Redshift cluster
  RedshiftSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for Redshift cluster
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 5439
          ToPort: 5439
          CidrIp: !Ref VpcCidr
      SecurityGroupEgress:
        - IpProtocol: -1
          FromPort: -1
          ToPort: -1
          CidrIp: 0.0.0.0/0

  # Redshift cluster subnet group
  RedshiftSubnetGroup:
    Type: AWS::Redshift::ClusterSubnetGroup
    Properties:
      Description: Subnet group for Redshift cluster
      SubnetIds: !Ref RedshiftSubnets

  # IAM role for Redshift
  RedshiftRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: redshift.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess

  # Lambda function to initialize Redshift tables
  RedshiftInitLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub RedshiftInit-${Environment}
      Handler: index.handler
      Role: !GetAtt RedshiftInitRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import time
          import logging

          # Set up logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          redshift_data = boto3.client('redshift-data')
          
          def execute_sql(sql, database, cluster_id, db_user):
              logger.info(f"Executing SQL on cluster: {cluster_id}, database: {database}")
              try:
                  # Execute the SQL statement
                  response = redshift_data.execute_statement(
                      Database=database,
                      ClusterIdentifier=cluster_id,
                      DbUser=db_user,
                      Sql=sql
                  )
                  statement_id = response['Id']
                  
                  # Wait for the statement to complete
                  while True:
                      status = redshift_data.describe_statement(Id=statement_id)
                      if status['Status'] in ['FINISHED', 'FAILED', 'ABORTED']:
                          if status['Status'] != 'FINISHED':
                              error_message = status.get('Error', 'Unknown error')
                              raise Exception(f"SQL execution failed: {error_message}")
                          break
                      time.sleep(2)
                  
                  return statement_id
              except Exception as e:
                  logger.error(f"Error executing SQL: {str(e)}")
                  raise
          
          def handler(event, context):
              logger.info(f"Event received: {json.dumps(event)}")
              response_data = {}
              
              try:
                  if event['RequestType'] in ['Create', 'Update']:
                      cluster_id = event['ResourceProperties']['ClusterId']
                      database = event['ResourceProperties']['Database']
                      db_user = event['ResourceProperties']['DbUser']
                      
                      # Define table creation SQL statements - execute one at a time
                      sql_statements = [
                          """
                          DROP TABLE IF EXISTS playlists;
                          CREATE TABLE playlists (
                              playlist_id BIGINT IDENTITY(1,1) PRIMARY KEY,
                              name VARCHAR(255) NOT NULL,
                              description VARCHAR(255),
                              s3_artkey VARCHAR(512),
                              created_at TIMESTAMP DEFAULT GETDATE(),
                              updated_at TIMESTAMP DEFAULT GETDATE()
                          );
                          """,
                          """
                          DROP TABLE IF EXISTS songs;
                          CREATE TABLE songs (
                              song_id BIGINT IDENTITY(1,1) PRIMARY KEY,
                              title VARCHAR(255) NOT NULL,
                              author VARCHAR(255) NOT NULL,
                              performer VARCHAR(255) NOT NULL,
                              ISRC VARCHAR(255),
                              ISWC VARCHAR(255),
                              IPI VARCHAR(255),
                              code VARCHAR(255),
                              duration VARCHAR(8),
                              s3_key VARCHAR(512) NOT NULL,
                              s3_artkey VARCHAR(512),
                              uploaded_at TIMESTAMP DEFAULT GETDATE()
                          );
                          """,
                          """
                          DROP TABLE IF EXISTS playlist_songs;
                          CREATE TABLE playlist_songs (
                              playlist_id BIGINT REFERENCES playlists(playlist_id),
                              song_id BIGINT REFERENCES songs(song_id),
                              added_at TIMESTAMP DEFAULT GETDATE(),
                              PRIMARY KEY (playlist_id, song_id)
                          );
                          """,
                          """
                          DROP TABLE IF EXISTS stream_analytics;
                          CREATE TABLE stream_analytics (
                              stream_id BIGINT IDENTITY(1,1) PRIMARY KEY,
                              song_id BIGINT REFERENCES songs(song_id),
                              user_id BIGINT,
                              stream_duration INTEGER,
                              streamed_at TIMESTAMP DEFAULT GETDATE()
                          );
                          """,
                          """
                          DROP TABLE IF EXISTS playlist_permissions;
                          CREATE TABLE playlist_permissions (
                              permission_id BIGINT IDENTITY(1,1) PRIMARY KEY,
                              user_id VARCHAR(255),
                              playlist_id BIGINT REFERENCES playlists(playlist_id),
                              granted_at TIMESTAMP DEFAULT GETDATE()
                          );
                          """,
                      ]
                      
                      # Execute each statement separately
                      for sql in sql_statements:
                          statement_id = execute_sql(sql.strip(), database, cluster_id, db_user)
                          logger.info(f"Successfully executed statement: {statement_id}")
                      
                      response_data['Message'] = 'Database initialized successfully'
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  else:
                      response_data['Message'] = 'No action required for DELETE'
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                      
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  response_data['Error'] = str(e)
                  cfnresponse.send(event, context, cfnresponse.FAILED, response_data)
      Runtime: python3.10
      Timeout: 300
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment

  # IAM role for RedshiftInit Lambda
  RedshiftInitRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: RedshiftDataAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                Resource: '*'  # Redshift Data API requires '*' for these actions
              - Effect: Allow
                Action:
                  - redshift:GetClusterCredentials
                  - redshift:DescribeClusters
                Resource: 
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbuser:${RedshiftCluster}/*
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbname:${RedshiftCluster}/*

  # Custom resource to trigger database initialization
  RedshiftInitTrigger:
    Type: Custom::RedshiftInit
    DependsOn: RedshiftCluster
    Properties:
      ServiceToken: !GetAtt RedshiftInitLambda.Arn
      ClusterId: !Sub ayauplay-cluster-${Environment}
      Database: ayauplaydb
      DbUser: !Ref RedshiftMasterUsername

  # Lambda function to record streaming data
  RecordStreamLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub RecordStreamLambda-${Environment}
      Handler: index.handler
      Role: !GetAtt RecordStreamLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import uuid
          import os

          redshift_data = boto3.client('redshift-data')

          def handler(event, context):
              try:
                  body = json.loads(event['body'])
                  song_id = body['song_id']
                  stream_duration = body['stream_duration']

                  # Extract user information from Cognito claims
                  claims = event['requestContext']['authorizer']['claims']
                  user_id = claims['sub']

                  sql = f"""
                  INSERT INTO stream_analytics (stream_id, song_id, user_id, stream_duration, streamed_at)
                  VALUES ('{uuid.uuid4()}', '{song_id}', '{user_id}', {stream_duration}, GETDATE());
                  """

                  response = redshift_data.execute_statement(
                      ClusterIdentifier=os.environ['REDSHIFT_CLUSTER_ID'],
                      Database=os.environ['REDSHIFT_DATABASE'],
                      DbUser=os.environ['REDSHIFT_DB_USER'],
                      Sql=sql
                  )

                  return {
                      'statusCode': 200,
                      'headers': {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,POST"
                      },
                      'body': json.dumps('Stream data recorded successfully')
                  }
              except Exception as e:
                  return {
                      'statusCode': 500,
                      'headers': {
                          "Access-Control-Allow-Origin": "*",
                          "Access-Control-Allow-Headers": "Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token",
                          "Access-Control-Allow-Methods": "OPTIONS,POST"
                      },
                      'body': json.dumps(f'Error: {str(e)}')
                  }
      Runtime: python3.10
      Environment:
        Variables:
          ENVIRONMENT: !Ref Environment
          REDSHIFT_CLUSTER_ID: !Sub ayauplay-cluster-${Environment}
          REDSHIFT_DATABASE: ayauplaydb
          REDSHIFT_DB_USER: !Ref RedshiftMasterUsername

  # IAM role for RecordStreamLambda
  RecordStreamLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: RedshiftDataAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - redshift-data:ExecuteStatement
                  - redshift-data:DescribeStatement
                Resource: '*'  # Redshift Data API requires '*' for these actions
              - Effect: Allow
                Action:
                  - redshift:GetClusterCredentials
                  - redshift:DescribeClusters
                Resource: 
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:cluster:${RedshiftCluster}
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbuser:${RedshiftCluster}/*
                  - !Sub arn:aws:redshift:${AWS::Region}:${AWS::AccountId}:dbname:${RedshiftCluster}/*

  # API Gateway resource for the record stream endpoint
  RecordStreamResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: record-stream
      RestApiId: !Ref ApiGateway

  # API Gateway method for the record stream endpoint
  RecordStreamMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: ApiGatewayAuthorizer
    Properties:
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref ApiGatewayAuthorizer
      HttpMethod: POST
      ResourceId: !Ref RecordStreamResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'https://ayauplay.ayaumusic.com'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST'"
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${RecordStreamLambda.Arn}/invocations
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
      RequestParameters:
        method.request.header.Authorization: true
        method.request.header.Origin: false
        method.request.header.Access-Control-Request-Method: false
        method.request.header.Access-Control-Request-Headers: false

  # Permission for API Gateway to invoke the RecordStreamLambda function
  RecordStreamLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt RecordStreamLambda.Arn
      Principal: apigateway.amazonaws.com

  # API Gateway to expose the Lambda function
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub UploadSongsApi-${Environment}
      EndpointConfiguration:
        Types:
          - REGIONAL
      BinaryMediaTypes:
        - '*/*'

  # API Gateway resource for the upload endpoint
  ApiGatewayResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId  # Root resource ID
      PathPart: upload  # Path part for the resource
      RestApiId: !Ref ApiGateway  # Reference to the API Gateway

  # API Gateway method for the upload endpoint
  ApiGatewayMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: ApiGatewayAuthorizer
    Properties:
      AuthorizationType: COGNITO_USER_POOLS  # Use Cognito user pools for authorization
      AuthorizerId: !Ref ApiGatewayAuthorizer  # Reference to the authorizer
      HttpMethod: POST  # HTTP method
      ResourceId: !Ref ApiGatewayResource  # Reference to the resource
      RestApiId: !Ref ApiGateway  # Reference to the API Gateway
      Integration:
        IntegrationHttpMethod: POST  # HTTP method for integration
        Type: AWS_PROXY  # Use AWS_PROXY integration type
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt UploadSongsLambda.Arn  # Lambda function ARN
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'https://ayauplay.ayaumusic.com'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'POST'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
      RequestParameters:
        method.request.header.Authorization: true
        method.request.header.Origin: false
        method.request.header.Access-Control-Request-Method: false
        method.request.header.Access-Control-Request-Headers: false

  # OPTIONS method for the upload endpoint
  ApiGatewayOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref ApiGatewayResource
      RestApiId: !Ref ApiGateway
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        PassthroughBehavior: WHEN_NO_MATCH
        ContentHandling: CONVERT_TO_TEXT
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'https://ayauplay.ayaumusic.com'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
            ContentHandling: CONVERT_TO_TEXT
            ResponseTemplates:
              application/json: '{}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
          ResponseModels:
            application/json: 'Empty'

  # Defines the /playlists resource endpoint in API Gateway
  # This resource handles all playlist-related operations
  PlaylistResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      # Set this resource as a child of the API's root path
      ParentId: !GetAtt ApiGateway.RootResourceId
      # Creates the /playlists path segment
      PathPart: playlists
      RestApiId: !Ref ApiGateway

  # Configures the GET method for the /playlists endpoint
  # This endpoint supports:
  # - Listing all playlists: GET /playlists
  # - Getting songs in a playlist: GET /playlists?playlist=<playlist_name>
  PlaylistGetMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: ApiGatewayAuthorizer
    Properties:
      # Requires authentication via Cognito User Pools
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref ApiGatewayAuthorizer
      HttpMethod: GET
      ResourceId: !Ref PlaylistResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt PlaylistManagementLambda.Arn
      # Configures the optional 'playlist' query parameter
      # When present, it retrieves songs from a specific playlist
      # When absent, it lists all available playlists
      RequestParameters:
        method.request.header.Authorization: true
        method.request.header.Origin: false
        method.request.header.Access-Control-Request-Method: false
        method.request.header.Access-Control-Request-Headers: false
        method.request.querystring.playlist: false
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true

  # OPTIONS method for the /playlists endpoint
  PlaylistOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref PlaylistResource
      RestApiId: !Ref ApiGateway
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        PassthroughBehavior: WHEN_NO_MATCH
        ContentHandling: CONVERT_TO_TEXT
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
              method.response.header.Access-Control-Allow-Origin: "'https://ayauplay.ayaumusic.com'"
              method.response.header.Access-Control-Max-Age: "'7200'"
            ContentHandling: CONVERT_TO_TEXT
            ResponseTemplates:
              application/json: '{}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Max-Age: true
          ResponseModels:
            application/json: 'Empty'

  # API Gateway resource for the retrieve songs endpoint
  RetrieveSongsResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: retrieve-songs
      RestApiId: !Ref ApiGateway

  # API Gateway method for the retrieve songs endpoint
  RetrieveSongsMethod:
    Type: AWS::ApiGateway::Method
    DependsOn: ApiGatewayAuthorizer
    Properties:
      AuthorizationType: COGNITO_USER_POOLS
      AuthorizerId: !Ref ApiGatewayAuthorizer
      HttpMethod: GET  # Changed from POST to GET
      ResourceId: !Ref RetrieveSongsResource
      RestApiId: !Ref ApiGateway
      Integration:
        IntegrationHttpMethod: POST
        Type: AWS_PROXY
        Uri: !Sub
          - arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${LambdaArn}/invocations
          - LambdaArn: !GetAtt RetrieveSongsLambda.Arn
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'https://ayauplay.ayaumusic.com'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
      RequestParameters:
        method.request.header.Authorization: true
        method.request.header.Origin: false
        method.request.header.Access-Control-Request-Method: false
        method.request.header.Access-Control-Request-Headers: false
        method.request.querystring.playlist_id: true  # Add playlist_id as required query parameter

  # OPTIONS method for the retrieve songs endpoint
  RetrieveSongsOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref RetrieveSongsResource
      RestApiId: !Ref ApiGateway
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        PassthroughBehavior: WHEN_NO_MATCH
        ContentHandling: CONVERT_TO_TEXT
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'https://ayauplay.ayaumusic.com'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'GET,OPTIONS'"
            ContentHandling: CONVERT_TO_TEXT
            ResponseTemplates:
              application/json: '{}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
          ResponseModels:
            application/json: 'Empty'

  # OPTIONS method for the record stream endpoint
  RecordStreamOptionsMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: OPTIONS
      ResourceId: !Ref RecordStreamResource
      RestApiId: !Ref ApiGateway
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        PassthroughBehavior: WHEN_NO_MATCH
        ContentHandling: CONVERT_TO_TEXT
        RequestTemplates:
          application/json: '{"statusCode": 200}'
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'https://ayauplay.ayaumusic.com'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token'"
              method.response.header.Access-Control-Allow-Methods: "'OPTIONS,POST'"
            ContentHandling: CONVERT_TO_TEXT
            ResponseTemplates:
              application/json: '{}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
          ResponseModels:
            application/json: 'Empty'

  # Permission for API Gateway to invoke the RetrieveSongsLambda function
  RetrieveSongsLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt RetrieveSongsLambda.Arn
      Principal: apigateway.amazonaws.com

  # Cognito User Pools Authorizer configuration
  # This authorizer validates JWT tokens issued by Cognito
  # and ensures only authenticated users can access the API
  ApiGatewayAuthorizer:
    Type: AWS::ApiGateway::Authorizer
    Properties:
      # Friendly name for the authorizer
      Name: CognitoAuthorizer
      # Specifies where to look for the JWT token in incoming requests
      # The token should be provided in the Authorization header
      IdentitySource: method.request.header.Authorization
      RestApiId: !Ref ApiGateway
      # Configures this as a Cognito User Pools authorizer
      Type: COGNITO_USER_POOLS
      # Links this authorizer to the Cognito User Pool
      ProviderARNs:
        - !GetAtt UserPool.Arn
      AuthorizerResultTtlInSeconds: 0

  # Permission for API Gateway to invoke the Lambda function
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction  # Allow invocation of the Lambda function
      FunctionName: !GetAtt UploadSongsLambda.Arn  # Lambda function ARN
      Principal: apigateway.amazonaws.com  # Principal for API Gateway

  PlaylistLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      Action: lambda:InvokeFunction
      FunctionName: !GetAtt PlaylistManagementLambda.Arn
      Principal: apigateway.amazonaws.com

  # Create a user pool client for authentication
  UserPoolClient:
    Type: AWS::Cognito::UserPoolClient
    Properties:
      UserPoolId: !Ref UserPool
      ClientName: !Sub UserPoolClient-${Environment}
      GenerateSecret: false
      ExplicitAuthFlows:
        - ALLOW_USER_PASSWORD_AUTH
        - ALLOW_REFRESH_TOKEN_AUTH

  # WAF WebACL to protect the API Gateway
  WAFWebACL:
    Type: AWS::WAFv2::WebACL
    Properties:
      Name: !Sub WebACL-${Environment}  # Name of the WebACL
      Scope: REGIONAL  # Scope of the WebACL
      DefaultAction:
        Block: {}  # Default action is to block requests
      VisibilityConfig:
        SampledRequestsEnabled: true  # Enable sampling of requests
        CloudWatchMetricsEnabled: true  # Enable CloudWatch metrics
        MetricName: !Sub WebACL-${Environment}  # Metric name
      Rules:
        # Allow requests from the specified domain
        - Name: AllowSpecificOrigin
          Priority: 0
          Action:
            Allow: {}
          Statement:
            ByteMatchStatement:
              SearchString: 'https://ayauplay.ayaumusic.com'
              FieldToMatch:
                SingleHeader:
                  Name: origin
              TextTransformations:
                - Priority: 1
                  Type: NONE
              PositionalConstraint: EXACTLY
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AllowSpecificOrigin
        # Rate limiting rule to prevent DDoS attacks
        - Name: RateLimitRule
          Priority: 1
          Action:
            Block: {}
          Statement:
            RateBasedStatement:
              Limit: 100  # Limit to 100 requests per 5 minutes
              AggregateKeyType: IP  # Aggregate by IP address
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: RateLimitRule
            
        # Rule to block requests with body size greater than 50MB
        - Name: MaxFileSize
          Priority: 2
          Action:
            Block: {}
          Statement:
            SizeConstraintStatement:
              ComparisonOperator: GT
              Size: 52428800  # 50MB max file size
              FieldToMatch:
                Body: {}
              TextTransformations:
                - Type: NONE
                  Priority: 1
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: MaxFileSize

        # Content type validation for audio files
        - Name: AudioFilesOnly
          Priority: 3
          Action:
            Block: {}
          Statement:
            OrStatement:
              Statements:
                - ByteMatchStatement:
                    SearchString: audio/wav
                    FieldToMatch:
                      SingleHeader:
                        Name: content-type
                    TextTransformations:
                      - Priority: 1
                        Type: LOWERCASE
                    PositionalConstraint: EXACTLY
                - ByteMatchStatement:
                    SearchString: audio/mpeg
                    FieldToMatch:
                      SingleHeader:
                        Name: content-type
                    TextTransformations:
                      - Priority: 1
                        Type: LOWERCASE
                    PositionalConstraint: EXACTLY
                - ByteMatchStatement:
                    SearchString: audio/aac
                    FieldToMatch:
                      SingleHeader:
                        Name: content-type
                    TextTransformations:
                      - Priority: 1
                        Type: LOWERCASE
                    PositionalConstraint: EXACTLY
                - ByteMatchStatement:
                    SearchString: multipart/form-data
                    FieldToMatch:
                      SingleHeader:
                        Name: content-type
                    TextTransformations:
                      - Priority: 1
                        Type: LOWERCASE
                    PositionalConstraint: CONTAINS
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AudioFilesOnly

        # AWS managed rule group for common security threats
        - Name: AWS-AWSManagedRulesCommonRuleSet
          Priority: 4
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesCommonRuleSet
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSManagedRulesCommonRuleSet

        # AWS managed rule group for known bad inputs
        - Name: AWS-AWSManagedRulesKnownBadInputsRuleSet
          Priority: 5
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesKnownBadInputsRuleSet
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSManagedRulesKnownBadInputsRuleSet

        # AWS managed rule group for SQL injection protection
        - Name: AWS-AWSManagedRulesSQLiRuleSet
          Priority: 6
          OverrideAction:
            None: {}
          Statement:
            ManagedRuleGroupStatement:
              VendorName: AWS
              Name: AWSManagedRulesSQLiRuleSet
          VisibilityConfig:
            SampledRequestsEnabled: true
            CloudWatchMetricsEnabled: true
            MetricName: AWSManagedRulesSQLiRuleSet

        # Allow requests from localhost in dev environment
        - !If
          - IsDev
          - Name: AllowLocalhostDev
            Priority: 7
            Action:
              Allow: {}
            Statement:
              ByteMatchStatement:
                SearchString: 'localhost:5173'
                FieldToMatch:
                  SingleHeader:
                    Name: origin
                TextTransformations:
                  - Priority: 1
                    Type: NONE
                PositionalConstraint: EXACTLY
            VisibilityConfig:
              SampledRequestsEnabled: true
              CloudWatchMetricsEnabled: true
              MetricName: AllowLocalhostDev
          - !Ref "AWS::NoValue"

  # API Gateway deployment configuration
  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn: 
      - ApiGatewayAuthorizer
      - UserPoolClient
      - ApiGatewayMethod
      - PlaylistGetMethod
      - RetrieveSongsMethod
      - RecordStreamMethod
    Properties:
      RestApiId: !Ref ApiGateway

  # Add CloudWatch role for API Gateway
  ApiGatewayCloudWatchRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AmazonAPIGatewayPushToCloudWatchLogs

  # Add CloudWatch account settings for API Gateway
  ApiGatewayAccount:
    Type: AWS::ApiGateway::Account
    Properties:
      CloudWatchRoleArn: !GetAtt ApiGatewayCloudWatchRole.Arn

  # Add CloudWatch Log Group for API Gateway access logs
  ApiGatewayAccessLogGroup:
    Type: AWS::Logs::LogGroup
    Properties:
      LogGroupName: !Sub /aws/apigateway/${Environment}-ayauplay-api
      RetentionInDays: 7

  # Update API Gateway stage configuration with logging
  ApiGatewayStage:
    Type: AWS::ApiGateway::Stage
    DependsOn: 
      - ApiGatewayDeployment
      - ApiGatewayAccount
    Properties:
      DeploymentId: !Ref ApiGatewayDeployment
      RestApiId: !Ref ApiGateway
      StageName: !Ref Environment
      MethodSettings:
        - HttpMethod: '*'
          ResourcePath: '/*'
          LoggingLevel: ERROR
          MetricsEnabled: true
          DataTraceEnabled: true
      AccessLogSetting:
        DestinationArn: !GetAtt ApiGatewayAccessLogGroup.Arn
        Format: '{"requestId":"$context.requestId","ip":"$context.identity.sourceIp","caller":"$context.identity.caller","user":"$context.identity.user","requestTime":"$context.requestTime","httpMethod":"$context.httpMethod","resourcePath":"$context.resourcePath","status":"$context.status","protocol":"$context.protocol","responseLength":"$context.responseLength"}'

  # WAF WebACL association with the API Gateway stage
  # Commenting out this section to disable WAF temporarily
  # WAFWebACLAssociation:
  #   Type: AWS::WAFv2::WebACLAssociation
  #   Properties:
  #     ResourceArn: !Sub arn:aws:apigateway:${AWS::Region}:${AWS::AccountId}:/restapis/${ApiGateway}/stages/${Environment}
  #     WebACLArn: !GetAtt WAFWebACL.Arn
  #   DependsOn:
  #     - ApiGatewayStage

Conditions:
  IsDev:
    Fn::Equals:
      - !Ref Environment
      - dev

Outputs:
  # Output the URL for the API Gateway
  ApiGatewayUrl:
    Description: URL for the API Gateway
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/upload

  PlaylistApiUrl:
    Description: URL for the Playlist API Gateway
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/playlists

  RetrieveSongsApiUrl:
    Description: URL for the Retrieve Songs API Gateway
    Value: !Sub https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/retrieve-songs

  CloudFrontDomain:
    Description: CloudFront Distribution Domain Name
    Value: !GetAtt SongsDistribution.DomainName

  RedshiftClusterEndpoint:
    Description: Endpoint for Redshift cluster
    Value: !Sub ${RedshiftCluster.Endpoint.Address}:${RedshiftCluster.Endpoint.Port}
